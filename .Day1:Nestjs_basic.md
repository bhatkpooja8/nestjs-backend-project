Day 1 — Architecture & Basics (Theory):
Express.js:
No structure → routes, services, and logic mixed in files
No DI (Dependency Injection)

Request Lifecycle in NestJS:

HTTP Request
    ↓
Middleware         → Pre-processing (logging, headers, auth check)
    ↓
Guard              → Authorization/Access control
    ↓
Interceptor (Before) → Modify request / start timer
    ↓
Pipe               → Validate/Transform input data
    ↓
Controller         → Receives request, delegates to service
    ↓
Service            → Business logic / data handling
    ↓
Controller         → Returns response
    ↓
Interceptor (After) → Modify response / log duration
    ↓
HTTP Response


Modules:
groups related controller and service files along with importing the databases

benefits:keep related code together
avoid messy structure

Controllers:
Handle incoming HTTP requests
Delegate business logic to services
Return responses
@Controller('route')
Methods annotated with @Get(), @Post(), @Put(), @Delete()
shdnt contain business logic

Services:
Contain business logic
Manage data (DB, in-memory, API calls)

Annotated with @Injectable() → marks it as a provider
Can be injected anywhere in the module (DI)

Dependency Injection (DI):
DI = automatic creation & injection of dependencies
Instead of manually creating objects:

const service = new EmployeesService() // ❌ bad
NestJS injects service automatically:
constructor(private readonly employeesService: EmployeesService) {}


DAY 1 [PRACTICAL CLASS]:

npm install -g @nestjs/cli - nestjs command line interface , -g is global , npm is a package manager which install, manage dependencies, and run scripts

main.ts

➡️ App entry point
➡️ Starts NestJS & HTTP server

app.module.ts

➡️ Root module
➡️ Imports all feature modules

app.controller.ts

➡️ Example controller

app.service.ts

➡️ Example service
Generate module
nest g module employees

Generate controller
nest g controller employees

generate service

nest g service employees

src/
 ├── app.module.ts
 └── employees/
     ├── employees.module.ts
     ├── employees.controller.ts
     └── employees.service.ts


Created a project for backend with employees details , no db created interface and 2 get api , fetch all, fetchby id

whenever u pass from api for fetch by id 1 ->it will be in string format so need to use pipe ParseIntPipe
Pipe: validation and trasformation which converts to integer

here for todays day 1 conecpt practically we covered:
Main
Modules
feature Module
controller
service

Dependency injection which is added using constructor(){} 
inService we are using @Injectable which can be injected anywhere
Controller - @Controller()
Also basics of Pipes is used
Validation:
{
    "message": "Validation failed (numeric string is expected)",
    "error": "Bad Request",
    "statusCode": 400
}

Trasformation : Convert from default string to numeric

Unit Testing of those api are done








